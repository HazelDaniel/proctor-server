import { loadYjsProtocols } from 'src/import-resolution/yjs';
import type {
  ToolDefinition,
  ValidationResult,
  ValidationError,
} from '../../types';
import type { Doc } from 'yjs' with { 'resolution-mode': 'import' };

type JsonObj = Record<string, unknown>;

function isObj(v: unknown): v is JsonObj {
  return typeof v === 'object' && v !== null && !Array.isArray(v);
}

function asStr(v: unknown): string | null {
  return typeof v === 'string' && v.trim().length ? v : null;
}

function pushErr(errors: ValidationError[], path: string, message: string) {
  errors.push({ path, message });
}

function asStrArray(v: unknown): string[] | null {
  if (!Array.isArray(v)) return null;
  const out: string[] = [];
  for (const x of v) {
    const s = asStr(x);
    if (!s) return null;
    out.push(s);
  }
  return out;
}

function sqlIdent(name: string) {
  // simple safe quoting for identifiers
  return `"${name.replace(/"/g, '""')}"`;
}

export class SchemaDesignTool {
  readonly definition: ToolDefinition = {
    type: 'schema-design',

    async initDocument() {
      const doc: Doc = new (await loadYjsProtocols()).YJS.Doc();

      doc.getMap('tables');
      doc.getMap('keys');
      doc.getMap('references');
      doc.getMap('compositions');
      doc.getMap('meta').set('schemaVersion', 1);

      return doc;
    },

    compile(doc): string {
      const tablesMap = doc.getMap('tables');
      const keysMap = doc.getMap('keys');
      const refsMap = doc.getMap('references');

      // Build table lookup: id -> { name, columns? }
      const tablesById = new Map<
        string,
        {
          name: string;
          columns?: Array<{
            name: string;
            type?: string;
            nullable?: boolean;
            default?: unknown;
          }>;
        }
      >();

      tablesMap.forEach((v, id) => {
        const tid = asStr(id);
        if (!tid || !isObj(v)) return;
        const name = asStr(v.name);
        if (!name) return;

        const columnsRaw = v.columns;
        let columns:
          | Array<{
              name: string;
              type?: string;
              nullable?: boolean;
              default?: unknown;
            }>
          | undefined;

        if (Array.isArray(columnsRaw)) {
          const parsed: Array<{
            name: string;
            type?: string;
            nullable?: boolean;
            default?: unknown;
          }> = [];
          for (const c of columnsRaw) {
            if (!isObj(c)) continue;
            const cn = asStr(c.name);
            if (!cn) continue;
            parsed.push({
              name: cn,
              type: asStr(c.type) ?? undefined,
              nullable:
                typeof c.nullable === 'boolean' ? c.nullable : undefined,
              default: c.default,
            });
          }
          columns = parsed.length ? parsed : undefined;
        }

        tablesById.set(tid, { name, columns });
      });

      // Deterministic table order
      const tables = Array.from(tablesById.entries())
        .map(([id, t]) => ({ id, ...t }))
        .sort((a, b) => a.name.localeCompare(b.name));

      // Key lookup: id -> { tableId, name, kind?, columns? }
      const keysById = new Map<
        string,
        { tableId: string; name: string; kind?: string; columns?: string[] }
      >();
      keysMap.forEach((v, id) => {
        const kid = asStr(id);
        if (!kid || !isObj(v)) return;

        const tableId = asStr(v.tableId);
        const name = asStr(v.name);
        if (!tableId || !name) return;

        const kind = asStr(v.kind) ?? undefined;
        const cols = asStrArray(v.columns) ?? undefined;

        keysById.set(kid, { tableId, name, kind, columns: cols });
      });

      const out: string[] = [];
      out.push('-- Generated by schema-design tool');
      out.push('-- Dialect: PostgreSQL');
      out.push('');

      // 1) CREATE TABLE
      for (const t of tables) {
        const cols = t.columns;
        if (!cols || cols.length === 0) {
          out.push(`CREATE TABLE ${sqlIdent(t.name)} ();`);
          out.push('');
          continue;
        }

        const colLines: string[] = [];
        for (const c of cols) {
          const type = c.type ?? 'text';
          const nullable = c.nullable === false ? ' NOT NULL' : '';
          const def =
            c.default === undefined
              ? ''
              : typeof c.default === 'string'
                ? ` DEFAULT '${String(c.default).replace(/"/g, '""')}'`
                : ` DEFAULT ${String(c.default as string)}`;
          colLines.push(`  ${sqlIdent(c.name)} ${type}${def}${nullable}`);
        }

        out.push(`CREATE TABLE ${sqlIdent(t.name)} (`);
        out.push(colLines.join(',\n'));
        out.push(');');
        out.push('');
      }

      // 2) Constraints from keys (primary/unique) when possible
      // Deterministic order by table name then key name
      const keyConstraints = Array.from(keysById.entries())
        .map(([id, k]) => ({ id, ...k }))
        .filter(
          (k) =>
            (k.kind === 'primary' || k.kind === 'unique') &&
            Array.isArray(k.columns) &&
            k.columns.length > 0,
        )
        .sort((a, b) => {
          const ta = tablesById.get(a.tableId)?.name ?? a.tableId;
          const tb = tablesById.get(b.tableId)?.name ?? b.tableId;
          return ta.localeCompare(tb) || a.name.localeCompare(b.name);
        });

      for (const k of keyConstraints) {
        const tname = tablesById.get(k.tableId)?.name;
        if (!tname) {
          out.push(`-- Skipped key ${k.id}: tableId '${k.tableId}' not found`);
          continue;
        }

        const cols = (k.columns ?? []).map(sqlIdent).join(', ');
        const cname = `${tname}_${k.name}`;

        if (k.kind === 'primary') {
          out.push(
            `ALTER TABLE ${sqlIdent(tname)} ADD CONSTRAINT ${sqlIdent(cname)} PRIMARY KEY (${cols});`,
          );
        } else {
          out.push(
            `ALTER TABLE ${sqlIdent(tname)} ADD CONSTRAINT ${sqlIdent(cname)} UNIQUE (${cols});`,
          );
        }
      }
      if (keyConstraints.length) out.push('');

      // 3) Foreign keys from references when possible
      type RefRec = {
        id: string;
        fromTableId?: string;
        toTableId?: string;
        fromKeyId?: string;
        toKeyId?: string;
        fromColumns?: string[];
        toColumns?: string[];
        name?: string;
      };
      const refs: RefRec[] = [];

      refsMap.forEach((v, id) => {
        const rid = asStr(id) ?? String(id);
        if (!isObj(v)) return;

        refs.push({
          id: rid,
          fromTableId: asStr(v.fromTableId) ?? undefined,
          toTableId: asStr(v.toTableId) ?? undefined,
          fromKeyId: asStr(v.fromKeyId) ?? undefined,
          toKeyId: asStr(v.toKeyId) ?? undefined,
          fromColumns: asStrArray(v.fromColumns) ?? undefined,
          toColumns: asStrArray(v.toColumns) ?? undefined,
          name: asStr(v.name) ?? undefined,
        });
      });

      // Deterministic order: fromTableName, toTableName, refId
      refs.sort((a, b) => {
        const fa =
          tablesById.get(a.fromTableId ?? '')?.name ?? a.fromTableId ?? '';
        const fb =
          tablesById.get(b.fromTableId ?? '')?.name ?? b.fromTableId ?? '';
        const ta = tablesById.get(a.toTableId ?? '')?.name ?? a.toTableId ?? '';
        const tb = tablesById.get(b.toTableId ?? '')?.name ?? b.toTableId ?? '';
        return (
          fa.localeCompare(fb) ||
          ta.localeCompare(tb) ||
          a.id.localeCompare(b.id)
        );
      });

      for (const r of refs) {
        const fromName = r.fromTableId
          ? tablesById.get(r.fromTableId)?.name
          : undefined;
        const toName = r.toTableId
          ? tablesById.get(r.toTableId)?.name
          : undefined;

        if (!fromName || !toName) {
          out.push(
            `-- Skipped reference ${r.id}: from/to table not resolvable`,
          );
          continue;
        }

        let fromCols = r.fromColumns;
        let toCols = r.toColumns;

        // Attempt to resolve via keys if columns not explicit
        if ((!fromCols || !toCols) && r.fromKeyId && r.toKeyId) {
          const fk = keysById.get(r.fromKeyId);
          const pk = keysById.get(r.toKeyId);
          if (fk?.columns?.length && pk?.columns?.length) {
            fromCols = fk.columns;
            toCols = pk.columns;
          }
        }

        if (
          !fromCols?.length ||
          !toCols?.length ||
          fromCols.length !== toCols.length
        ) {
          out.push(
            `-- Skipped reference ${r.id}: missing or mismatched from/to columns`,
          );
          continue;
        }

        const cname = r.name
          ? `${fromName}_${r.name}`
          : `${fromName}_fk_${r.id}`;
        out.push(
          `ALTER TABLE ${sqlIdent(fromName)} ADD CONSTRAINT ${sqlIdent(cname)} FOREIGN KEY (${fromCols.map(sqlIdent).join(', ')}) REFERENCES ${sqlIdent(toName)} (${toCols.map(sqlIdent).join(', ')});`,
        );
      }

      return out.join('\n');
    },

    validate(doc): ValidationResult {
      const errors: ValidationError[] = [];

      const tables = doc.getMap('tables');
      const keys = doc.getMap('keys');
      const references = doc.getMap('references');
      const compositions = doc.getMap('compositions');
      const meta = doc.getMap('meta');

      // meta schemaVersion
      const schemaVersion = meta.get('schemaVersion');
      if (typeof schemaVersion !== 'number') {
        pushErr(errors, 'meta.schemaVersion', 'schemaVersion must be a number');
      }

      // Basic sanity: maps exist (getMap always returns a map, but keep for safety)
      if (!tables) pushErr(errors, 'tables', 'tables map missing');
      if (!keys) pushErr(errors, 'keys', 'keys map missing');
      if (!references) pushErr(errors, 'references', 'references map missing');
      if (!compositions)
        pushErr(errors, 'compositions', 'compositions map missing');

      // Collect tables + check uniqueness by name
      const tableIds = new Set<string>();
      const tableNameToId = new Map<string, string>();

      tables.forEach((value, id) => {
        if (!asStr(id)) {
          pushErr(
            errors,
            `tables.${String(id)}`,
            'table id must be a non-empty string',
          );
          return;
        }
        tableIds.add(id);

        if (!isObj(value)) {
          pushErr(errors, `tables.${id}`, 'table value must be an object');
          return;
        }

        const name = asStr(value.name);
        if (!name) {
          pushErr(
            errors,
            `tables.${id}.name`,
            'table name must be a non-empty string',
          );
          return;
        }

        const existing = tableNameToId.get(name.toLowerCase());
        if (existing && existing !== id) {
          pushErr(
            errors,
            `tables.${id}.name`,
            `duplicate table name '${name}' (already used by ${existing})`,
          );
        } else {
          tableNameToId.set(name.toLowerCase(), id);
        }
      });

      // Collect keys + validate tableId linkage
      const keyIds = new Set<string>();
      keys.forEach((value, id) => {
        if (!asStr(id)) {
          pushErr(
            errors,
            `keys.${String(id)}`,
            'key id must be a non-empty string',
          );
          return;
        }
        keyIds.add(id);

        if (!isObj(value)) {
          pushErr(errors, `keys.${id}`, 'key value must be an object');
          return;
        }

        const tableId = asStr(value.tableId);
        if (!tableId) {
          pushErr(
            errors,
            `keys.${id}.tableId`,
            'key.tableId must be a non-empty string',
          );
        } else if (!tableIds.has(tableId)) {
          pushErr(
            errors,
            `keys.${id}.tableId`,
            `tableId '${tableId}' does not exist`,
          );
        }

        const name = asStr(value.name);
        if (!name) {
          pushErr(
            errors,
            `keys.${id}.name`,
            'key name must be a non-empty string',
          );
        }
      });

      // Validate references
      references.forEach((value, id) => {
        const refId = asStr(id) ?? String(id);

        if (!isObj(value)) {
          pushErr(
            errors,
            `references.${refId}`,
            'reference value must be an object',
          );
          return;
        }

        const fromTableId = asStr(value.fromTableId);
        const toTableId = asStr(value.toTableId);

        if (!fromTableId)
          pushErr(
            errors,
            `references.${refId}.fromTableId`,
            'fromTableId must be a non-empty string',
          );
        else if (!tableIds.has(fromTableId))
          pushErr(
            errors,
            `references.${refId}.fromTableId`,
            `table '${fromTableId}' does not exist`,
          );

        if (!toTableId)
          pushErr(
            errors,
            `references.${refId}.toTableId`,
            'toTableId must be a non-empty string',
          );
        else if (!tableIds.has(toTableId))
          pushErr(
            errors,
            `references.${refId}.toTableId`,
            `table '${toTableId}' does not exist`,
          );

        const fromKeyId = asStr(value.fromKeyId);
        if (fromKeyId && !keyIds.has(fromKeyId)) {
          pushErr(
            errors,
            `references.${refId}.fromKeyId`,
            `key '${fromKeyId}' does not exist`,
          );
        }

        const toKeyId = asStr(value.toKeyId);
        if (toKeyId && !keyIds.has(toKeyId)) {
          pushErr(
            errors,
            `references.${refId}.toKeyId`,
            `key '${toKeyId}' does not exist`,
          );
        }
      });

      // Validate compositions (composite keys etc.)
      compositions.forEach((value, id) => {
        const compId = asStr(id) ?? String(id);

        if (!isObj(value)) {
          pushErr(
            errors,
            `compositions.${compId}`,
            'composition value must be an object',
          );
          return;
        }

        const keyIdsVal = value.keyIds;
        if (
          !Array.isArray(keyIdsVal) ||
          keyIdsVal.some((k) => typeof k !== 'string' || !k)
        ) {
          pushErr(
            errors,
            `compositions.${compId}.keyIds`,
            'keyIds must be an array of non-empty strings',
          );
          return;
        }

        for (let i = 0; i < keyIdsVal.length; i++) {
          const k = keyIdsVal[i] as string;
          if (!keyIds.has(k)) {
            pushErr(
              errors,
              `compositions.${compId}.keyIds[${i}]`,
              `key '${k}' does not exist`,
            );
          }
        }
      });

      return { valid: errors.length === 0, errors };
    },

    snapshotPolicy: {
      maxUpdates: 100,
      maxIntervalMs: 30_000,
    },
  };
}
